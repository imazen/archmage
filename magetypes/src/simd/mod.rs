//! Token-gated SIMD types with natural operators.
//!
//! This module re-exports all generated SIMD types from `generated/`.
//! The actual implementations are auto-generated by `cargo xtask generate`.
//!
//! ## Usage
//!
//! ```ignore
//! use magetypes::simd::*;
//! use archmage::{SimdToken, X64V3Token};
//!
//! if let Some(token) = X64V3Token::summon() {
//!     let a = f32x8::splat(token, 1.0);
//!     let b = f32x8::splat(token, 2.0);
//!     let c = a + b;
//! }
//! ```

// All generated code lives in the generated/ subfolder.
// The old per-platform types have been replaced by generic strategy-pattern types.
// All 20 types (f32x4, f32x8, f64x2, f64x4, i8x16, i8x32, u8x16, u8x32,
// i16x8, i16x16, u16x8, u16x16, i32x4, i32x8, u32x4, u32x8, i64x2, i64x4,
// u64x2, u64x4) are generic type aliases below. Only W512 types (avx512)
// still use old generated code.
mod generated;

// Scalar polyfill types (f32x1, i32x1, etc.) for #[magetypes] fallback
pub mod scalar;

// Re-export non-migrated types from generated module
pub use generated::*;

// Re-export scalar types
pub use scalar::*;

// ============================================================================
// Strategy-pattern generic SIMD types
//
// The generic types use `f32x8<T>` where `T` is a backend token type
// (X64V3Token, NeonToken, ScalarToken, etc.). Write one function generic
// over `T: F32x8Backend`, get monomorphized per backend at dispatch time.
// ============================================================================

/// Backend traits that define SIMD operations per token type.
pub mod backends;

/// Backend trait implementations for each token type.
mod impls;

/// Generic SIMD types parameterized by backend (e.g., `generic::f32x8<x64v3>`).
pub mod generic;

// ============================================================================
// Type aliases: map the 10 migrated type names to their generic versions.
//
// On x86_64, `f32x8` = `generic::f32x8<X64V3Token>` (backed by __m256).
// On x86_64, `f32x4` = `generic::f32x4<X64V3Token>` (backed by __m128).
//
// These aliases ensure existing code using `simd::f32x8::splat(token, 1.0)`
// continues to work unchanged, while gaining the ability to write generic
// functions over `T: F32x8Backend`.
//
// Old concrete types remain accessible at their full paths:
//   `simd::x86::w256::f32x8` (old per-platform type)
// ============================================================================

#[allow(non_camel_case_types)]
mod _type_aliases {
    /// 4-lane f32 SIMD vector (generic, backed by native intrinsics).
    #[cfg(target_arch = "x86_64")]
    pub type f32x4 = super::generic::f32x4<archmage::X64V3Token>;

    /// 8-lane f32 SIMD vector (generic, backed by native intrinsics).
    #[cfg(target_arch = "x86_64")]
    pub type f32x8 = super::generic::f32x8<archmage::X64V3Token>;

    /// 2-lane f64 SIMD vector (generic, backed by native intrinsics).
    #[cfg(target_arch = "x86_64")]
    pub type f64x2 = super::generic::f64x2<archmage::X64V3Token>;

    /// 4-lane f64 SIMD vector (generic, backed by native intrinsics).
    #[cfg(target_arch = "x86_64")]
    pub type f64x4 = super::generic::f64x4<archmage::X64V3Token>;

    /// 4-lane i32 SIMD vector (generic, backed by native intrinsics).
    #[cfg(target_arch = "x86_64")]
    pub type i32x4 = super::generic::i32x4<archmage::X64V3Token>;

    /// 8-lane i32 SIMD vector (generic, backed by native intrinsics).
    #[cfg(target_arch = "x86_64")]
    pub type i32x8 = super::generic::i32x8<archmage::X64V3Token>;

    /// 4-lane u32 SIMD vector (generic, backed by native intrinsics).
    #[cfg(target_arch = "x86_64")]
    pub type u32x4 = super::generic::u32x4<archmage::X64V3Token>;

    /// 8-lane u32 SIMD vector (generic, backed by native intrinsics).
    #[cfg(target_arch = "x86_64")]
    pub type u32x8 = super::generic::u32x8<archmage::X64V3Token>;

    /// 2-lane i64 SIMD vector (generic, backed by native intrinsics).
    #[cfg(target_arch = "x86_64")]
    pub type i64x2 = super::generic::i64x2<archmage::X64V3Token>;

    /// 4-lane i64 SIMD vector (generic, backed by native intrinsics).
    #[cfg(target_arch = "x86_64")]
    pub type i64x4 = super::generic::i64x4<archmage::X64V3Token>;

    /// 16-lane i8 SIMD vector (generic, backed by native intrinsics).
    #[cfg(target_arch = "x86_64")]
    pub type i8x16 = super::generic::i8x16<archmage::X64V3Token>;

    /// 32-lane i8 SIMD vector (generic, backed by native intrinsics).
    #[cfg(target_arch = "x86_64")]
    pub type i8x32 = super::generic::i8x32<archmage::X64V3Token>;

    /// 16-lane u8 SIMD vector (generic, backed by native intrinsics).
    #[cfg(target_arch = "x86_64")]
    pub type u8x16 = super::generic::u8x16<archmage::X64V3Token>;

    /// 32-lane u8 SIMD vector (generic, backed by native intrinsics).
    #[cfg(target_arch = "x86_64")]
    pub type u8x32 = super::generic::u8x32<archmage::X64V3Token>;

    /// 8-lane i16 SIMD vector (generic, backed by native intrinsics).
    #[cfg(target_arch = "x86_64")]
    pub type i16x8 = super::generic::i16x8<archmage::X64V3Token>;

    /// 16-lane i16 SIMD vector (generic, backed by native intrinsics).
    #[cfg(target_arch = "x86_64")]
    pub type i16x16 = super::generic::i16x16<archmage::X64V3Token>;

    /// 8-lane u16 SIMD vector (generic, backed by native intrinsics).
    #[cfg(target_arch = "x86_64")]
    pub type u16x8 = super::generic::u16x8<archmage::X64V3Token>;

    /// 16-lane u16 SIMD vector (generic, backed by native intrinsics).
    #[cfg(target_arch = "x86_64")]
    pub type u16x16 = super::generic::u16x16<archmage::X64V3Token>;

    /// 2-lane u64 SIMD vector (generic, backed by native intrinsics).
    #[cfg(target_arch = "x86_64")]
    pub type u64x2 = super::generic::u64x2<archmage::X64V3Token>;

    /// 4-lane u64 SIMD vector (generic, backed by native intrinsics).
    #[cfg(target_arch = "x86_64")]
    pub type u64x4 = super::generic::u64x4<archmage::X64V3Token>;
}
pub use _type_aliases::*;
